/*国庆期间,省城HZ刚刚举行了一场盛大的集体婚礼,为了使婚礼进行的丰富一些,司仪临时想出了有一个有意思的节目,叫做"考新郎",具体的操作是这样的:
首先,给每位新娘打扮得几乎一模一样,并盖上大大的红盖头随机坐成一排;
然后,让各位新郎寻找自己的新娘.每人只准找一个,并且不允许多人找一个.
最后,揭开盖头,如果找错了对象就要当众跪搓衣板...
看来做新郎也不是容易的事情...
假设一共有N对新婚夫妇,其中有M个新郎找错了新娘,求发生这种情况一共有多少种可能.
Input
输入数据的第一行是一个整数C,表示测试实例的个数，然后是C行数据，每行包含两个整数N和M(1<M<=N<=20)。
Output
对于每个测试实例，请输出一共有多少种发生这种情况的可能，每个实例的输出占一行。
Sample Input
2
2 2
3 2
Sample Output
1
3*/

//本题需要用到错排公式
// 特殊地，D(1) = 0, D(2) = 1.

// 首先，对于D(n)，有1~n这样n个元素错排，所以对于第一个元素①，它现在可能的位置有    (n-1)个。   这是递推公式需要乘（n-1）的原因
// 倘若它在第k个元素的位置上，对于第k个元素而言，它所在的位置就有两种可能—第一种，它处在非第一个元素①位置上，
// 所以对于接下来的排列就相当于是n-1个元素的错排，即D(n-1);第二种，它处在第一个元素①的位置上，
// 所以在排列D(n)中有两个元素找到了位置，那么接下来的队列就相当于是n-2个元素的错排。
// 因此，对于D(n)都有       D(n) = (n-1) [D(n-2) + D(n-1)]


#include<iostream>  //这道题的本质就是求解排列组合C(n,m)与错排m个元素D(m)的乘积
#include<cstdio>
using namespace std;
const int maxn = 25;
long long D[maxn], N[maxn]; /// D[i]表示错排数，N[i]表示全排列数(即n!)
int main()
{
	D[0] = 0, N[0] = 1; 
	D[1] = 0, N[1] = 1;
	D[2] = 1, N[2] = 2;//递推边界
	for (int i = 3; i < maxn; i++)
	{
		D[i] = (i - 1)*(D[i - 1] + D[i - 2]);///错排递推关系式
		N[i] = N[i - 1] * i;//求n
	}
	int T, n, m;
	cin >> T;
	while (T--)
	{
		cin >> n >> m;
		long long a = N[n] / (N[m] * N[n - m]); ///求C(n,m)组合数   n!/(m!*(n-m)!)
		cout << D[m] * a << endl;
	}
	return 0;
}