/*Problem Description
HDU 2006'10 ACM contest的颁奖晚会隆重开始了！
为了活跃气氛，组织者举行了一个别开生面、奖品丰厚的抽奖活动，这个活动的具体要求是这样的：

首先，所有参加晚会的人员都将一张写有自己名字的字条放入抽奖箱中；
然后，待所有字条加入完毕，每人从箱中取一个字条；
最后，如果取得的字条上写的就是自己的名字，那么“恭喜你，中奖了！”
大家可以想象一下当时的气氛之热烈，毕竟中奖者的奖品是大家梦寐以求的Twins签名照呀！
不过，正如所有试图设计的喜剧往往以悲剧结尾，这次抽奖活动最后竟然没有一个人中奖！
我的神、上帝以及老天爷呀，怎么会这样呢？
不过，先不要激动，现在问题来了，你能计算一下发生这种情况的概率吗？
不会算？难道你也想以悲剧结尾？！
Input
输入数据的第一行是一个整数C,表示测试实例的个数，然后是C 行数据，每行包含一个整数n(1<n<=20),表示参加抽奖的人数。
Output
对于每个测试实例，请输出发生这种情况的百分比，每个实例的输出占一行, 结果保留两位小  数(四舍五入)，具体格式请参照sample output。
Sample Input
1
2
Sample Output
50.00%*/

//本题需要用到错排公式
// 特殊地，D(1) = 0, D(2) = 1.

// 首先，对于D(n)，有1~n这样n个元素错排，所以对于第一个元素①，它现在可能的位置有    (n-1)个。   这是递推公式需要乘（n-1）的原因
// 倘若它在第k个元素的位置上，对于第k个元素而言，它所在的位置就有两种可能—第一种，它处在非第一个元素①位置上，
// 所以对于接下来的排列就相当于是n-1个元素的错排，即D(n-1);第二种，它处在第一个元素①的位置上，
// 所以在排列D(n)中有两个元素找到了位置，那么接下来的队列就相当于是n-2个元素的错排。
// 因此，对于D(n)都有       D(n) = (n-1) [D(n-2) + D(n-1)]


#include <iostream>
#include <iomanip>
using namespace std;

long long a[20], b[20];

int main() {
    a[0] = 0;
    a[1] = 1;
    b[0] = 1;
    b[1] = 2;
    
    for (int i = 2; i < 20; i++) {
        b[i] = (i + 1) * b[i - 1];
        a[i] = i * (a[i - 2] + a[i - 1]);
    }
    
    int n;
    cin >> n;
    while (n--) {
        int x;
        cin >> x;
        cout << fixed << setprecision(2) << a[x - 1] * 100.0 / b[x - 1] << "%" << endl;
    }
    return 0;
}